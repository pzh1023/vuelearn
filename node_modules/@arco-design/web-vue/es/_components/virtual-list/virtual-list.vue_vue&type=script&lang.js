import { defineComponent, toRefs, computed, ref, reactive, onUnmounted, watch, nextTick } from "vue";
import { isUndefined, isString, isFunction } from "../../_utils/is.js";
import { caf, raf } from "../../_utils/raf.js";
import usePickSlots from "../../_hooks/use-pick-slots.js";
import ResizeObserver from "../resize-observer.js";
import RenderFunction from "../render-function.js";
import Filler from "./filler.js";
import { useViewportHeight } from "./hooks/use-viewport-height.js";
import { useItemHeight } from "./hooks/use-item-height.js";
import { useRenderChildren } from "./hooks/use-render-children.js";
import { useRangeState } from "./hooks/use-range-state.js";
import { useScrollTo } from "./hooks/use-scroll-to.js";
import { getItemAbsoluteTop, getValidScrollTop, getScrollPercentage } from "./utils/index.js";
var _sfc_main = defineComponent({
  name: "VirtualList",
  components: {
    ResizeObserver,
    Filler,
    RenderFunction
  },
  inheritAttrs: false,
  props: {
    height: {
      type: [Number, String],
      default: 200
    },
    threshold: {
      type: [Number, Object]
    },
    isStaticItemHeight: {
      type: Boolean
    },
    estimatedItemHeight: {
      type: Number
    },
    data: {
      type: Array,
      default: () => []
    },
    itemKey: {
      type: [String, Function],
      default: "key"
    },
    component: {
      type: String,
      default: "div"
    },
    type: String,
    outerAttrs: Object,
    innerAttrs: Object
  },
  emits: ["scroll", "resize"],
  setup(props, {
    slots,
    emit
  }) {
    const {
      height,
      itemKey,
      data,
      estimatedItemHeight: propEstimatedItemHeight,
      isStaticItemHeight,
      threshold
    } = toRefs(props);
    function getItemKey(item, index) {
      let result;
      if (isString(itemKey.value)) {
        result = item[itemKey.value];
      } else if (isFunction(itemKey.value)) {
        result = itemKey.value(item);
      }
      return result != null ? result : index;
    }
    const internalData = computed(() => (data.value || []).map((item, index) => ({
      key: getItemKey(item, index),
      index,
      item
    })));
    const viewportRef = ref();
    const {
      viewportHeight,
      setViewportHeight,
      needMeasureViewportHeight
    } = useViewportHeight(reactive({
      height
    }));
    const {
      itemHeight,
      minItemHeight,
      totalHeight,
      setItemHeight,
      getItemHeight,
      getItemHeightOrDefault,
      getItemHeightOrDefaultByIndex
    } = useItemHeight(reactive({
      estimatedItemHeight: propEstimatedItemHeight,
      data: internalData
    }));
    const itemCount = computed(() => internalData.value.length);
    const visibleCount = computed(() => Math.ceil(viewportHeight.value / minItemHeight.value));
    const scrollTop = ref(0);
    const startOffset = ref(0);
    const {
      rangeState,
      updateRangeState
    } = useRangeState(reactive({
      viewportRef,
      itemCount,
      visibleCount
    }));
    const visibleData = computed(() => {
      const start = rangeState.startIndex;
      const end = Math.min(rangeState.endIndex + 1, itemCount.value);
      return internalData.value.slice(start, end);
    });
    const isVirtual = computed(() => (threshold == null ? void 0 : threshold.value) !== null && ((threshold == null ? void 0 : threshold.value) === void 0 || itemCount.value >= threshold.value) && totalHeight.value > viewportHeight.value);
    const scrollListPadding = computed(() => {
      if (!isUndefined(viewportRef.value)) {
        const viewport = viewportRef.value;
        const getPadding = (property) => +window.getComputedStyle(viewport)[property].replace(/\D/g, "");
        return {
          top: getPadding("paddingTop"),
          bottom: getPadding("paddingBottom")
        };
      }
      return {
        top: 0,
        bottom: 0
      };
    });
    const itemRender = usePickSlots(slots, "item");
    const renderChildren = useRenderChildren(reactive({
      internalData,
      visibleData,
      itemRender
    }), {
      onItemResize(el, key) {
        if (el && isUndefined(getItemHeight(key))) {
          if (isStaticItemHeight.value) {
            setItemHeight(key, itemHeight.value);
          } else {
            const height2 = el.offsetHeight;
            if (height2) {
              setItemHeight(key, height2);
            }
          }
        }
      }
    });
    const updateScrollOffset = () => {
      if (!viewportRef.value || !isVirtual.value)
        return;
      const {
        scrollTop: scrollTop2,
        clientHeight,
        scrollHeight
      } = viewportRef.value;
      const scrollPtg = getScrollPercentage({
        scrollTop: scrollTop2,
        clientHeight,
        scrollHeight
      });
      let newStartOffset = getItemAbsoluteTop({
        scrollPtg,
        clientHeight,
        scrollTop: scrollTop2 - (scrollListPadding.value.top + scrollListPadding.value.bottom) * scrollPtg,
        itemHeight: getItemHeightOrDefaultByIndex(rangeState.itemIndex),
        itemOffsetPtg: rangeState.itemOffsetPtg
      });
      for (let index = rangeState.itemIndex - 1; index >= rangeState.startIndex; index--) {
        newStartOffset -= getItemHeightOrDefaultByIndex(index);
      }
      startOffset.value = newStartOffset;
    };
    const rafIdRef = ref();
    onUnmounted(() => {
      rafIdRef.value && caf(rafIdRef.value);
    });
    const lockScrollRef = ref(false);
    const {
      fixScrollTo,
      prepareScrollTo
    } = useScrollTo(reactive({
      isVirtual,
      isStaticItemHeight,
      rangeState,
      data: internalData,
      viewportRef,
      scrollTop,
      visibleCount,
      getItemHeightOrDefault,
      getItemHeightOrDefaultByIndex
    }));
    const handleResize = (entry) => {
      handleWrapperResize(entry);
      emit("resize", entry);
    };
    const handleWrapperResize = (entry) => {
      if (needMeasureViewportHeight.value) {
        setViewportHeight(entry.clientHeight);
      }
    };
    const handleScroll = (e) => {
      if (!viewportRef.value)
        return;
      const {
        scrollTop: rawScrollTop,
        clientHeight,
        scrollHeight
      } = viewportRef.value;
      scrollTop.value = getValidScrollTop(rawScrollTop, scrollHeight - clientHeight);
      emit("scroll", e);
    };
    const scrollTo = (options) => {
      rafIdRef.value && caf(rafIdRef.value);
      rafIdRef.value = raf(() => {
        const prepareScrollResult = prepareScrollTo(options);
        if (prepareScrollResult) {
          rangeState.startIndex = prepareScrollResult.startIndex;
          rangeState.endIndex = prepareScrollResult.endIndex;
          nextTick(() => {
            if (!viewportRef.value)
              return;
            const fixScrollResult = fixScrollTo({
              itemIndex: prepareScrollResult.itemIndex,
              relativeTop: prepareScrollResult.relativeTop
            });
            if (fixScrollResult) {
              lockScrollRef.value = true;
              viewportRef.value.scrollTop = fixScrollResult.scrollTop;
              rangeState.itemIndex = fixScrollResult.itemIndex;
              rangeState.itemOffsetPtg = fixScrollResult.itemOffsetPtg;
              rangeState.startIndex = fixScrollResult.startIndex;
              rangeState.endIndex = fixScrollResult.endIndex;
            }
            rafIdRef.value = raf(() => {
              lockScrollRef.value = false;
            });
          });
        }
      });
    };
    watch([itemHeight, visibleCount, scrollTop, data], () => {
      if (lockScrollRef.value)
        return;
      updateRangeState();
    });
    watch(rangeState, () => {
      updateScrollOffset();
    });
    return {
      viewportRef,
      viewportHeight,
      totalHeight,
      startOffset,
      isVirtual,
      renderChildren,
      handleResize,
      handleScroll,
      scrollTo
    };
  }
});
export { _sfc_main as default };
