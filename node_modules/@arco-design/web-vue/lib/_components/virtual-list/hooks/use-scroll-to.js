"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports[Symbol.toStringTag] = "Module";
var vue = require("vue");
var algorithm = require("../utils/algorithm.js");
var index = require("../utils/index.js");
function useScrollTo(props) {
  const {
    isVirtual,
    isStaticItemHeight,
    data,
    rangeState,
    viewportRef,
    scrollTop,
    visibleCount,
    getItemHeightOrDefault,
    getItemHeightOrDefaultByIndex
  } = vue.toRefs(props);
  const itemCount = vue.computed(() => data.value.length);
  const getItemKeyByIndex = (index2) => {
    var _a;
    return (_a = data.value[index2]) == null ? void 0 : _a.key;
  };
  const fixScrollTo = (relativeScroll) => {
    if (!viewportRef.value)
      return null;
    const { itemIndex: compareItemIndex, relativeTop: compareItemRelativeTop } = relativeScroll;
    const { scrollHeight, clientHeight } = viewportRef.value;
    const originScrollTop = scrollTop.value;
    const maxScrollTop = scrollHeight - clientHeight;
    let bestSimilarity = Number.MAX_VALUE;
    let bestScrollTop = -1;
    let bestItemIndex = -1;
    let bestItemOffsetPtg = -1;
    let bestStartIndex = -1;
    let bestEndIndex = -1;
    let missSimilarity = 0;
    for (let i = 0; i < maxScrollTop; i++) {
      const scrollTop2 = algorithm.getIndexByStartLoc(0, maxScrollTop, originScrollTop, i);
      const scrollPtg = index.getScrollPercentage({
        scrollTop: scrollTop2,
        scrollHeight,
        clientHeight
      });
      const { itemIndex, itemOffsetPtg, startIndex, endIndex } = index.getRangeIndex(scrollPtg, itemCount.value, visibleCount.value);
      if (startIndex <= compareItemIndex && compareItemIndex <= endIndex) {
        const locatedItemRelativeTop = index.getItemRelativeTop({
          itemHeight: getItemHeightOrDefaultByIndex.value(itemIndex),
          itemOffsetPtg,
          clientHeight,
          scrollPtg
        });
        const compareItemTop = index.getCompareItemRelativeTop({
          locatedItemRelativeTop,
          locatedItemIndex: itemIndex,
          compareItemIndex,
          startIndex,
          endIndex,
          getItemKeyByIndex,
          getItemHeightOrDefault: getItemHeightOrDefault.value
        });
        const similarity = Math.abs(compareItemTop - compareItemRelativeTop);
        if (similarity < bestSimilarity) {
          bestSimilarity = similarity;
          bestScrollTop = scrollTop2;
          bestItemIndex = itemIndex;
          bestItemOffsetPtg = itemOffsetPtg;
          bestStartIndex = startIndex;
          bestEndIndex = endIndex;
          missSimilarity = 0;
        } else {
          missSimilarity += 1;
        }
      }
      if (missSimilarity > 10) {
        break;
      }
    }
    return bestScrollTop === -1 ? null : {
      scrollTop: bestScrollTop,
      itemIndex: bestItemIndex,
      itemOffsetPtg: bestItemOffsetPtg,
      startIndex: bestStartIndex,
      endIndex: bestEndIndex
    };
  };
  const prepareScrollTo = (options) => {
    if (!viewportRef.value)
      return null;
    if (typeof options === "number") {
      viewportRef.value.scrollTop = options;
      return null;
    }
    const index$1 = "index" in options ? options.index : "key" in options ? data.value.findIndex((item2) => item2.key === options.key) : 0;
    const item = data.value[index$1];
    if (!item) {
      return null;
    }
    let align = options.align || "auto";
    const { clientHeight, scrollTop: scrollTop2 } = viewportRef.value;
    if (isVirtual.value && !isStaticItemHeight.value) {
      if (align === "auto") {
        const { itemIndex, itemOffsetPtg } = rangeState.value;
        if (Math.abs(itemIndex - index$1) < visibleCount.value) {
          let itemTop2 = index.getItemRelativeTop({
            itemHeight: getItemHeightOrDefaultByIndex.value(index$1),
            itemOffsetPtg,
            clientHeight,
            scrollPtg: index.getScrollPercentage(viewportRef.value)
          });
          if (index$1 < itemIndex) {
            for (let i = index$1; i < itemIndex; i++) {
              itemTop2 -= getItemHeightOrDefaultByIndex.value(i);
            }
          } else {
            for (let i = itemIndex; i < index$1; i++) {
              itemTop2 += getItemHeightOrDefaultByIndex.value(i);
            }
          }
          if (itemTop2 < 0 || itemTop2 > clientHeight) {
            align = itemTop2 < 0 ? "top" : "bottom";
          } else {
            return null;
          }
        } else {
          align = index$1 < itemIndex ? "top" : "bottom";
        }
      }
      return {
        itemIndex: index$1,
        relativeTop: align === "top" ? 0 : clientHeight - getItemHeightOrDefaultByIndex.value(index$1),
        startIndex: Math.max(0, index$1 - visibleCount.value),
        endIndex: Math.min(itemCount.value - 1, index$1 + visibleCount.value)
      };
    }
    const indexItemHeight = getItemHeightOrDefaultByIndex.value(index$1);
    let itemTop = 0;
    for (let i = 0; i < index$1; i++) {
      itemTop += getItemHeightOrDefaultByIndex.value(i);
    }
    const itemBottom = itemTop + indexItemHeight;
    if (align === "auto") {
      if (itemTop < scrollTop2) {
        align = "top";
      } else if (itemBottom > scrollTop2 + clientHeight) {
        align = "bottom";
      }
    }
    if (align === "top") {
      viewportRef.value.scrollTop = itemTop;
    } else if (align === "bottom") {
      viewportRef.value.scrollTop = itemTop - (clientHeight - indexItemHeight);
    }
    return null;
  };
  return {
    fixScrollTo,
    prepareScrollTo
  };
}
exports.useScrollTo = useScrollTo;
